/*
C:\Users\Admin\shaurya\
#/include/fixparser.h

#pragma once
#include <vector>
#include <cstring>
#include <string>

struct StringViewLite {
    const char* data;
    size_t len;
    StringViewLite(const char* d, size_t l) : data(d), len(l) {}
    std::string toString() const { return std::string(data, len); }
};

struct FixMessage {
    char buffer[256];
    size_t length;
    long long arrivalTime;
};

class FixParser {
public:
    static void parse(const FixMessage& msg);
};

#/include/lockfreequeue.h

#pragma once
#include <vector>
#include <atomic>

#define CACHELINE_SIZE 64

template<typename T, size_t Size>
class LockFreeQueue {
    std::vector<T> buffer;

    alignas(CACHELINE_SIZE) std::atomic<size_t> head; 
    
    char padding[CACHELINE_SIZE - sizeof(std::atomic<size_t>)]; 
    
    alignas(CACHELINE_SIZE) std::atomic<size_t> tail; 

public:
    LockFreeQueue() : buffer(Size) {
        head.store(0);
        tail.store(0);
    }

    bool push(const T& item) {
        size_t currentHead = head.load(std::memory_order_relaxed);
        size_t nextHead = (currentHead + 1) % Size;

        if (nextHead == tail.load(std::memory_order_acquire)) {
            return false; 
        }

        buffer[currentHead] = item;
        head.store(nextHead, std::memory_order_release);
        return true;
    }

    bool pop(T& item) {
        size_t currentTail = tail.load(std::memory_order_relaxed);
        if (currentTail == head.load(std::memory_order_acquire)) {
            return false; 
        }

        item = buffer[currentTail];
        tail.store((currentTail + 1) % Size, std::memory_order_release);
        return true;
    }
};

#/include/logger.h

#pragma once
#include <iostream>
#include <mutex>
#include <string>

class Logger {
public:
    static std::mutex mux; 

    static void log(const std::string& msg) {
        std::lock_guard<std::mutex> lock(mux);
        std::cout << "[shaurya] " << msg << std::endl;
    }
};

#/include/networkclient.h

#pragma once
#include <string>
#include <winsock2.h>
#include <ws2tcpip.h>

class NetworkClient {
    SOCKET sock;
public:
    NetworkClient();
    ~NetworkClient(); 

    bool joinMulticast(const std::string& groupIP, int port);
    
    bool connectToServer(const std::string& ip, int port);

    SOCKET getSocket() const { return sock; }
};

#/include/ShauryaEngine.h

#pragma once
#include <string>
#include <thread>
#include <atomic>
#include <iostream>
#include "NetworkClient.h"
#include "LockFreeQueue.h"
#include "FixParser.h"
#include "Stats.h"
#include "Logger.h"

class ShauryaEngine {
    std::thread processorThread;
    std::thread networkThread;
    std::atomic<bool> running;
    NetworkClient client;
    LockFreeQueue<FixMessage, 1024> messageQueue; 
public:
    ShauryaEngine() : running(false) {}

    ~ShauryaEngine() {
        stop();
    }

    bool start(const std::string& ip, int port) {
        if (running) return false;
        running = true;

        processorThread = std::thread(&ShauryaEngine::processorLoop, this);

        if (!client.joinMulticast(ip, port)) {
            std::cerr << "[C++] Failed to join multicast.\n";
            running = false;
            if (processorThread.joinable()) processorThread.join();
            return false;
        }

        networkThread = std::thread(&ShauryaEngine::networkLoop, this);
        
        std::cout << "[C++] Engine Started. Listening on " << ip << ":" << port << "\n";
        return true;
    }

    void stop() {
        running = false;
        if (processorThread.joinable()) processorThread.join();
        if (networkThread.joinable()) networkThread.join();
        std::cout << "[C++] Engine Stopped.\n";
    }

    double getMinLatency() {
        if (Stats::latencies.empty()) return 0.0;
        return Stats::latencies.back(); 
    }

private:
    void processorLoop() {
        FixMessage msg;
        while (running) {
            if (messageQueue.pop(msg)) {
                FixParser::parse(msg);
            } else {
                 std::this_thread::sleep_for(std::chrono::nanoseconds(100));}
        }
    }

    void networkLoop() {
        char buffer[4096];
        sockaddr_in senderAddr;
        int senderLen = sizeof(senderAddr);
        SOCKET s = client.getSocket();

        LARGE_INTEGER frequency;
        QueryPerformanceFrequency(&frequency); 

        while (running) {
            int bytes = recvfrom(s, buffer, 4096, 0, (sockaddr*)&senderAddr, &senderLen);
            
            if (bytes > 0) {
                LARGE_INTEGER now;
                QueryPerformanceCounter(&now);

                FixMessage msg;
                if (bytes < 256) {
                    memcpy(msg.buffer, buffer, bytes);
                    msg.length = bytes;
                    msg.arrivalTime = now.QuadPart;
                    messageQueue.push(msg);
                }
            } 
            else {
                std::this_thread::sleep_for(std::chrono::microseconds(1));
            }
        }
    }
};

#/include/stats.h

#pragma once
#include <vector>
#include <algorithm>
#include <numeric>
#include <iostream>
#include <fstream>
#include <cmath>
#include <iomanip>

class Stats {
public:
    static std::vector<double> latencies;
    static void add(double microseconds) {
        latencies.push_back(microseconds);
    }

    static void saveReport(const std::string& filename) {
        if (latencies.empty()) {
            std::cout << "[Shaurya] No data collected.\n";
            return;
        }

        std::sort(latencies.begin(), latencies.end());

        double minLat = latencies.front();
        double maxLat = latencies.back();
        double sum = std::accumulate(latencies.begin(), latencies.end(), 0.0);
        double avg = sum / latencies.size();
        size_t p99Index = (size_t)(latencies.size() * 0.99);
        double p99 = latencies[p99Index];

        std::cout << "\n========================================\n";
        std::cout << "       PERFORMANCE REPORT (SHAURYA)     \n";
        std::cout << "========================================\n";
        std::cout << "Total Messages : " << latencies.size() << "\n";
        std::cout << "Min Latency    : " << minLat << " us\n";
        std::cout << "Max Latency    : " << maxLat << " us\n";
        std::cout << "Avg Latency    : " << avg << " us\n";
        std::cout << "99th Percentile: " << p99 << " us  <-- CRITICAL\n";
        std::cout << "========================================\n";

        std::ofstream file(filename.c_str());
        file << "SHAURYA HFT ENGINE - LATENCY REPORT\n";
        file << "-----------------------------------\n";
        file << "Total Messages : " << latencies.size() << "\n";
        file << "Avg Latency    : " << avg << " us\n";
        file << "Max Latency    : " << maxLat << " us\n";
        file << "P99 Latency    : " << p99 << " us\n\n";
        file << "--- Raw Data (Microseconds) ---\n";
        for (size_t i = 0; i < latencies.size(); ++i) {
             file << latencies[i] << "\n";
        }
        file.close();
        std::cout << "[Shaurya] Report saved to: " << filename << "\n";
    }
};


\src\bindings.cpp
C:\Users\Admin\shaurya\src\bindings.cpp

#include <pybind11/pybind11.h>
#include <thread>
#include <chrono>

#include "ShauryaEngine.h" 
#include "Logger.h"
#include "Stats.h"

std::mutex Logger::mux;
std::vector<double> Stats::latencies;

namespace py = pybind11;

class PyShaurya {
    ShauryaEngine engine;
public:
    void start(std::string ip, int port) {
        engine.start(ip, port);
    }
    
    double get_latency() {
        return engine.getMinLatency();
    }

    void stop() {
        engine.stop();
    }

    void run_backtest(std::string file) {
        py::gil_scoped_release release; 
    }
};

PYBIND11_MODULE(shaurya_hft, m) {
    m.doc() = "Shaurya Ultra-Low Latency Engine";

    py::class_<PyShaurya>(m, "Engine")
        .def(py::init<>())
        .def("start", &PyShaurya::start, "Start the HFT Engine connection")
        .def("stop", &PyShaurya::stop, "Stop the Engine")
        .def("get_latency", &PyShaurya::get_latency, "Get minimum recorded latency");
        .def("run_backtest", &PyShaurya::run_backtest);
}

C:\Users\Admin\shaurya\src\fixparser.cpp
#\src\fixparser.cpp

#include "../include/FixParser.h"
#include "../include/Logger.h"
#include "../include/Stats.h"
#include <iostream>
#include <windows.h> 
#include <string>
#include <sstream> 

template <typename T>
std::string to_string_custom(T value) {
    std::ostringstream os;
    os << value;
    return os.str();
}

void FixParser::parse(const FixMessage& msg) {
    const char* raw = msg.buffer;
    size_t len = msg.length;
    for (size_t i = 0; i < len - 4; ++i) {
        if (raw[i] == '2' && raw[i+1] == '7' && raw[i+2] == '0' && raw[i+3] == '=') { 
            size_t start = i + 4;
            size_t end = start;
            while (end < len && raw[end] != '\x01' && raw[end] != '|') {
                end++;}
            StringViewLite priceView(raw + start, end - start);
            LARGE_INTEGER now, freq;
            QueryPerformanceCounter(&now);
            QueryPerformanceFrequency(&freq); 
            long long ticks = now.QuadPart - msg.arrivalTime;
            double latencyUs = (double)(ticks * 1000000) / freq.QuadPart;
            if (latencyUs < 0.01) latencyUs = 0.1;
            Stats::add(latencyUs);
            std::string logMsg = "Price: " + priceView.toString()+" | Latency: " + to_string_custom(latencyUs) + " us";
            Logger::log(logMsg);
            return;
        }
    }
}

\src\main.cpp

#include <iostream>
#include <thread>
#include <atomic>
#include "../include/Logger.h"
#include "../include/LockFreeQueue.h"
#include "../include/NetworkClient.h"
#include "../include/FixParser.h"
#include "../include/Stats.h"
#include <windows.h> 

std::mutex Logger::mux;
std::vector<double> Stats::latencies;

LockFreeQueue<FixMessage, 1024> messageQueue;
std::atomic<bool> keepRunning(true);

void processorThreadFunc() {
    Logger::log("Processor Thread Started...");
    FixMessage msg;
    while (keepRunning) {
        if (messageQueue.pop(msg)) {
            FixParser::parse(msg);
        } else 
             Sleep(0);
    }
}

int main() {
    Logger::log("Starting Shaurya Engine (HFT Mode)...");

    std::thread processor(processorThreadFunc);

    NetworkClient client;
    if (!client.connectToServer("127.0.0.1", 5000)) {
        Logger::log("Failed to connect to Exchange!");
        return -1;
    }
    Logger::log("Connected. Listening for Market Data...");

    auto onDataReceived = [](const char* data, size_t len) {
        LARGE_INTEGER now;
        QueryPerformanceCounter(&now);

        FixMessage msg;
        if (len < 256) {
            memcpy(msg.buffer, data, len);
            msg.length = len;
            msg.arrivalTime = now.QuadPart; 
            messageQueue.push(msg);
        }
    };

    SOCKET s = client.getSocket();
    char buffer[4096];
    
    LARGE_INTEGER frequency;
    QueryPerformanceFrequency(&frequency);
    LARGE_INTEGER lastPacketTime;
    QueryPerformanceCounter(&lastPacketTime);
    
    bool receivedAnyData = false;

    while (true) {
        int bytes = recv(s, buffer, 4096, 0);
        
        if (bytes > 0) {
            onDataReceived(buffer, bytes);
            QueryPerformanceCounter(&lastPacketTime);
            receivedAnyData = true;
        } 
        else {
            LARGE_INTEGER now;
            QueryPerformanceCounter(&now);
            
            double elapsedSeconds = (double)(now.QuadPart - lastPacketTime.QuadPart) / frequency.QuadPart;
            
            if (receivedAnyData && elapsedSeconds > 2.0) { 
                Logger::log("Market Data ended. Generating Report...");
                break; 
            }
        }
    }

    keepRunning = false;
    processor.join(); 
    Stats::saveReport("Shaurya_Metrics.txt");
    return 0;
}

\src\networkclient.cpp

#include "../include/NetworkClient.h"
#include "../include/Logger.h"
#include <iostream>

NetworkClient::NetworkClient() : sock(INVALID_SOCKET) {
    WSADATA wsaData;
    WSAStartup(MAKEWORD(2, 2), &wsaData);
}

NetworkClient::~NetworkClient() {
    if (sock != INVALID_SOCKET) {
        closesocket(sock);
    }
    WSACleanup();
}

bool NetworkClient::joinMulticast(const std::string& groupIP, int port) {
    sock = socket(AF_INET, SOCK_DGRAM, 0);
    
    char reuse = 1;
    setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(reuse));

    sockaddr_in localAddr;
    localAddr.sin_family = AF_INET;
    localAddr.sin_port = htons(port);
    localAddr.sin_addr.s_addr = htonl(INADDR_ANY); 

    if (bind(sock, (sockaddr*)&localAddr, sizeof(localAddr)) < 0) {
        return false;
    }

    ip_mreq mreq;
    mreq.imr_multiaddr.s_addr = inet_addr(groupIP.c_str());
    mreq.imr_interface.s_addr = htonl(INADDR_ANY);
    
    if (setsockopt(sock, IPPROTO_IP, IP_ADD_MEMBERSHIP, (char*)&mreq, sizeof(mreq)) < 0) {
        return false;
    }

    u_long mode = 1;
    ioctlsocket(sock, FIONBIO, &mode);

    return true;
}

bool NetworkClient::connectToServer(const std::string& ip, int port) {
    sock = socket(AF_INET, SOCK_STREAM, 0);
    sockaddr_in serverAddr;
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_port = htons(port);
    serverAddr.sin_addr.s_addr = inet_addr(ip.c_str());

    if (connect(sock, (sockaddr*)&serverAddr, sizeof(serverAddr)) < 0) {
        return false;
    }
    
    u_long mode = 1;
    ioctlsocket(sock, FIONBIO, &mode);
    return true;
}

/bridge.py 

import asyncio
import websockets
import json
import socket

MULTICAST_GROUP = "239.0.0.1"
MULTICAST_PORT = 30001
RUN_DURATION = 120 

SOURCES = [
    {"name": "BINANCE",  "url": "wss://stream.binance.com:9443/ws/btcusdt@trade"},
    {"name": "COINBASE", "url": "wss://ws-feed.exchange.coinbase.com"},
    {"name": "BITSTAMP", "url": "wss://ws.bitstamp.net"}
]

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
sock.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, 2)

def send_multicast(fix_msg):
    try:
        sock.sendto(fix_msg.encode(), (MULTICAST_GROUP, MULTICAST_PORT))
    except Exception as e:
        print(f"[ERROR] UDP Send Failed: {e}")

async def stream_binance():
    url = SOURCES[0]["url"]
    async for websocket in websockets.connect(url):
        try:
            print(f"[CONNECT] Connected to {SOURCES[0]['name']}")
            while True:
                msg = await websocket.recv()
                data = json.loads(msg)
                price = data['p']
                fix = f"8=FIX.4.2\x0135=X\x0149=BINANCE\x0155=BTCUSDT\x01269=0\x01270={price}\x01"
                send_multicast(fix)
        except Exception:
            await asyncio.sleep(1)
            continue

async def stream_coinbase():
    url = SOURCES[1]["url"]
    async for websocket in websockets.connect(url):
        try:
            await websocket.send(json.dumps({
                "type": "subscribe",
                "product_ids": ["BTC-USD"],
                "channels": ["ticker"]
            }))
            print(f"[CONNECT] Connected to {SOURCES[1]['name']}")
            while True:
                msg = await websocket.recv()
                data = json.loads(msg)
                if 'price' in data:
                    price = data['price']
                    fix = f"8=FIX.4.2\x0135=X\x0149=COINBASE\x0155=BTCUSD\x01269=0\x01270={price}\x01"
                    send_multicast(fix)
        except Exception:
            await asyncio.sleep(1)
            continue

async def stream_bitstamp():
    url = SOURCES[2]["url"]
    async for websocket in websockets.connect(url):
        try:
            sub_msg = {
                "event": "bts:subscribe",
                "data": {"channel": "live_trades_btcusd"}
            }
            await websocket.send(json.dumps(sub_msg))
            print(f"[CONNECT] Connected to {SOURCES[2]['name']}")
            while True:
                msg = await websocket.recv()
                data = json.loads(msg)
                if 'data' in data and 'price' in data['data']:
                    price = data['data']['price']
                    fix = f"8=FIX.4.2\x0135=X\x0149=BITSTAMP\x0155=BTCUSD\x01269=0\x01270={price}\x01"
                    send_multicast(fix)
        except Exception:
            await asyncio.sleep(1)
            continue

async def main():
    print(f"[GATEWAY] Starting Multi-Exchange UDP Broadcast to {MULTICAST_GROUP}:{MULTICAST_PORT}")
    print(f"[GATEWAY] Aggregating Liquidity from Binance, Coinbase, Bitstamp...")

    tasks = [
        asyncio.create_task(stream_binance()),
        asyncio.create_task(stream_coinbase()),
        asyncio.create_task(stream_bitstamp())
    ]

    await asyncio.sleep(RUN_DURATION)
    
    print("\n[GATEWAY] Test Duration Complete. Stopping...")
    for task in tasks:
        task.cancel()

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("Gateway Stopped.")


C:\Users\Admin\shaurya\cmakelists.txt

cmake_minimum_required(VERSION 3.15)
project(shaurya_hft)

find_package(Python COMPONENTS Interpreter Development REQUIRED)
find_package(pybind11 CONFIG REQUIRED)

pybind11_add_module(shaurya_hft src/bindings.cpp src/FixParser.cpp src/NetworkClient.cpp)

if(MSVC)
    target_compile_options(shaurya_hft PRIVATE /O2)
else()
    target_compile_options(shaurya_hft PRIVATE -O3 -march=native)
endif()

target_include_directories(shaurya_hft PRIVATE include)
if(WIN32)
    target_link_libraries(shaurya_hft PRIVATE ws2_32)
endif()

install(TARGETS shaurya_hft DESTINATION .)

C:\Users\Admin\shaurya\build.bat

@echo off
echo ===============================
echo      BUILDING SHAURYA
echo ===============================

if not exist bin mkdir bin

echo [1/2] Compiling Mock Exchange...
g++ MockExchange.cpp -o bin/exo -lws2_32 -std=c++11

echo [2/2] Compiling Shaurya Engine...
g++ src/Main.cpp src/NetworkClient.cpp src/FixParser.cpp -o bin/Shaurya -lws2_32 -std=c++11 -O3

echo.
echo Build Complete.
pause
*/